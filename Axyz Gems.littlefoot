/*
<metadata description="v1.18 -- Turn your Lightpad Block into an expressive high resolution multi XYZ Pad controller." details="v1.18 -- Turn the entire surface into a high resolution multi XYZ pad with the addition of pressure (Z), sending out MIDI CC. Set the (primary) gem, high-resolution and MIDI channel. Use the send options to solo dimensions and easily map XYZ to different parameters in your DAW or instrument. The actual CC's are (per gem X, Y and Z respectively): Gem 1 (orange): CC2, CC11 and CC14 (especially nice for U-He plugins). Gem 2 (red): CC20, CC21 and CC22. Gem 3 (green): CC23, CC24 and CC25. Gem 4 (blue): CC26, CC27 and CC28. Gem 5 (pink): CC29, CC30 and CC31. If the high-resolution is turned on these CC's will also be counter parted with the extra LSB CC's. The side button advances the primary gem, but at any time other gems are accessible by using more than one finger. The lightpad will also reflect the received CC's and as such works bi-directional."
          target="Lightpad"
          tags="MIDI;Controller;">

<modes>
  <mode name="Default">
</mode>

</modes>

    <groups>
        <group name="gem1" displayName="Gem 1" />
        <group name="gem2" displayName="Gem 2" />
        <group name="gem3" displayName="Gem 3" />
        <group name="gem4" displayName="Gem 4" />
        <group name="gem5" displayName="Gem 5" />
    </groups>

   <variables>
        <variable name="orientation" displayName="Orientation" type="option" value="Left Side Button" options="Left Side Button;Top Side Button;Right Side Button;Bottom Side Button;" tooltip="Orientation of device"/>
        <variable name="active" displayName="Active Gems" type="option" value="All Gems" options="All Gems;Only Gem 1;Only Gem 2;Only Gem 3;Only Gem 4;Only Gem 5;Only Gems 2-5" tooltip="Active Gems"/>
        <variable name="primary" displayName="Primary Gem" type="int" min="1" max="5" value="1" displayMode="stepper" tooltip="Gem that will be accessed by the first touch." />
        <variable name="zscale" displayName="Z Scale" type="float" value="0.0" min="-1.0" max="1.0" tooltip="Amplify X &amp; Y by Z (pressure)" displayMode="bipolar"/>
        <variable name="zthreshold" displayName="Z Threshold" type="float" value="0.0" min="0.0" max="1.0" tooltip="How much Z (pressure) before scaling kicks in"/>
        <variable name="highres" displayName="High resolution" type="bool" value="true" tooltip="If this option is turned on the sent values will also be counter parted with the extra LSB CC's, giving them a much higher resolution (0 - 16383 instead of 0 - 127)"/>
        <variable name="channel" displayName="MIDI Channel" type="int" min="1" max="16" value="1" displayMode="stepper" tooltip="The MIDI channel that values are sent on"/>
        <variable name="recorder" displayName="Recorder" type="option" value="None" options="None;4 Beats;" tooltip="Recorder setting"/>
        <variable name="clearOnCenter" displayName="Clear on Center" type="bool" value="true" tooltip="If this option is turned on the Gems will be cleared if the are set to center position"/>


        <variable name="send" displayName="Send" type="option" value="X" options="All;X;Y;Z;" tooltip="Which parts of a touch should be sent" visible="false"/>
        <variable name="beat" displayName="Show beat dot" type="bool" value="false" visible="false"/>
        <variable name="setup" displayName="Setup page" type="bool" value="false" visible="false"/>

        <variable name="dot1" displayName="Colour" group="gem1" type="colour" value="0xFFFF7F00"/>
        <variable name="xCC1" displayName="X Axis CC" group="gem1" type="int" min="0" max="127" handleSetup="stepper" value="2ยง" handleSetup="stepper" />
        <variable name="yCC1" displayName="Y Axis CC" group="gem1" type="int" min="0" max="127" handleSetup="stepper" value="11" handleSetup="stepper" />
        <variable name="zCC1" displayName="Z Axis CC" group="gem1" type="int" min="0" max="127" handleSetup="stepper" value="14" handleSetup="stepper" />

        <variable name="dot2" displayName="Colour" group="gem2" type="colour" value="0xFFFF0000" />
        <variable name="xCC2" displayName="X Axis CC" group="gem2" type="int" min="0" max="127" handleSetup="stepper" value="20" handleSetup="stepper" />
        <variable name="yCC2" displayName="Y Axis CC" group="gem2" type="int" min="0" max="127" handleSetup="stepper" value="21" handleSetup="stepper" />
        <variable name="zCC2" displayName="Z Axis CC" group="gem2" type="int" min="0" max="127" handleSetup="stepper" value="22" handleSetup="stepper" />

        <variable name="dot3" displayName="Colour" group="gem3" type="colour" value="0xFF00FF00" />
        <variable name="xCC3" displayName="X Axis CC" group="gem3" type="int" min="0" max="127" handleSetup="stepper" value="23" handleSetup="stepper" />
        <variable name="yCC3" displayName="Y Axis CC" group="gem3" type="int" min="0" max="127" handleSetup="stepper" value="24" handleSetup="stepper" />
        <variable name="zCC3" displayName="Z Axis CC" group="gem3" type="int" min="0" max="127" handleSetup="stepper" value="25" handleSetup="stepper" />

        <variable name="dot4" displayName="Colour" group="gem4" type="colour" value="0xFF0000FF" />
        <variable name="xCC4" displayName="X Axis CC" group="gem4" type="int" min="0" max="127" handleSetup="stepper" value="26" handleSetup="stepper" />
        <variable name="yCC4" displayName="Y Axis CC" group="gem4" type="int" min="0" max="127" handleSetup="stepper" value="27" handleSetup="stepper" />
        <variable name="zCC4" displayName="Z Axis CC" group="gem4" type="int" min="0" max="127" handleSetup="stepper" value="28" handleSetup="stepper" />

        <variable name="dot5" displayName="Colour" group="gem5" type="colour" value="0xFFFF00FF" />
        <variable name="xCC5" displayName="X Axis CC" group="gem5" type="int" min="0" max="127" handleSetup="stepper" value="29" handleSetup="stepper" />
        <variable name="yCC5" displayName="Y Axis CC" group="gem5" type="int" min="0" max="127" handleSetup="stepper" value="30" handleSetup="stepper" />
        <variable name="zCC5" displayName="Z Axis CC" group="gem5" type="int" min="0" max="127" handleSetup="stepper" value="31" handleSetup="stepper" />

        <vector count="5" wantsGetFunctions="true" wantsSetFunctions="true">
            <variable name="flame" type="float" value="0.0" visible="false"/>
            <variable name="rnd" type="int" value="0" visible="false"/>
        </vector>

     </variables>
</metadata>
*/


// heapsize: ((1 + samples) * (gems * axyz * signif)
#heapsize: ((1 + 4) * (5 * 3 * 2))

/*
 * Heap layout is as follows:
 * gems 0 - 4, per axyz (x,y,z) 2 bytes
 *    byte 0 MSB
 *    byte 1 LSB
 *
 */

int maxSamples;
int maxGems;
int maxAxyz;
int maxSignif;

int heapOffset(int sample, int gem, int axyz, int signif)
{
    int result = 0;

    if (sample >= 0 && sample < maxSamples && gem >=0 && gem < maxGems && axyz >=0 && axyz < maxAxyz && signif >= 0 && signif < maxSignif) {
        result = (sample * maxGems * maxAxyz * maxSignif) + (gem * maxAxyz * maxSignif) + (axyz * maxSignif) + signif;
    }
    return result;
}


bool gammaCorrected;

int repaintCounter;
int performStamp;
int buttonStamp;
int breathCounter;
int clockStamp;
int clockCounter;
int beatCounter;
int pulseCounter;
bool playing;
int touching;
int touchBits;
int sampleIndex;
bool playback;
int recordCount;

bool beat4;
bool beat8;
bool beat16;

void initialise()
{
    maxSamples = 5;  // 1 + (4 * beat)
    maxGems = 5;
    maxAxyz = 3;
    maxSignif = 2;

    repaintCounter = 0;
    performStamp = 0;
    clockStamp = 0;
    beatCounter = -1;
    sampleIndex = -1;
    clockCounter = 0;
    pulseCounter = -1;
    playing = false;
    beat4 = false;
    beat8 = false;
    beat16 = false;
    touching = 0;
    touchBits = 0;
    playback = false;
    recordCount = ((recorder == 1) ? 4 : ((recorder == 2) ? 8 : 0));

    ensurePrimariIsActive();

	for (int i = 0; i < 32; ++i) {
        setLocalConfigActiveState (i, false, false);
	}

    setLocalConfig (33, 1);
    gammaCorrected = getLocalConfig (33);

    clearData();
}

/* gem is 1-based */
bool isActive(int gem) {
    if (active == 0) { // All
        if (gem >= 1 && gem <= 5) return true;
    } else if (active == 1) { // Gem 1
        if (gem == 1) return true;
    } else if (active == 2) { // Gem 2
        if (gem == 2) return true;
    } else if (active == 3) { // Gem 3
        if (gem == 3) return true;
    } else if (active == 4) { // Gem 4
        if (gem == 4) return true;
    } else if (active == 5) { // Gem 5
        if (gem == 5) return true;
    } else if (active == 6) { // Gems 2-5
        if (gem >= 2 && gem <= 5) return true;
    }
    return false;
}

/* index is 1-based */
int index2gem(int index) {
    int result = 0;
    if (active == 0) { // All
        if (index >= 1 && index <= 5) result = index;
    } else if (active == 1) { // Gem 1
        if (index == 1) result = 1;
    } else if (active == 2) { // Gem 2
        if (index == 1) result = 2;
    } else if (active == 3) { // Gem 3
        if (index == 1) result = 3;
    } else if (active == 4) { // Gem 4
        if (index == 1) result = 4;
    } else if (active == 5) { // Gem 5
        if (index == 1) result = 5;
    } else if (active == 6) { // Gems 2-5
        if (index >= 1 && index <= 4) result = index + 1;
    }

    if (result) {
        result = ((((active == 0?(primary - 1):(active == 6?(primary - 2):0)) + result) - 1) % 5) + 1;
        int count=0;
        while (!isActive(result) && count<maxGems) {
            count++;
            result++;
        }
    }

    return result;
}

int getXCC(int index)
{
    if (index == 0) return xCC1;
    if (index == 1) return xCC2;
    if (index == 2) return xCC3;
    if (index == 3) return xCC4;
    if (index == 4) return xCC5;

    return 0;
}

int getYCC(int index)
{
    if (index == 0) return yCC1;
    if (index == 1) return yCC2;
    if (index == 2) return yCC3;
    if (index == 3) return yCC4;
    if (index == 4) return yCC5;

    return 0;
}

int getZCC(int index)
{
    if (index == 0) return zCC1;
    if (index == 1) return zCC2;
    if (index == 2) return zCC3;
    if (index == 3) return zCC4;
    if (index == 4) return zCC5;

    return 0;
}

//==============================================================================
//  HSV to RGB conversion
//==============================================================================
/**
    All-integer function.
    NB! Currently this function does not provide range safety for
        h, s, v parameters

    Combines a set of 8-bit AHSV values into a 32-bit colour and returns the result.

    alpha   - The alpha in range 0 - 255 inclusive (1 byte)
    h       - The hue in range 0 - 255 inclusive (1 byte)
    s       - The saturation in range 0 - 255 inclusive (1 byte)
    v       - The value (brightness) in range 0 - 255 inclusive (1 byte)
    returns - a 32-bit colour
*/
// int makeARGBfromAHSV(int alpha, int h, int s, int v)
// {
//     // TODO: range safety for h, s, v parameters + test performance hit
//
//     // If grayscale:
//     if (s == 0)
//         return makeARGB(alpha, v, v, v);
//
//     int region     = h / 43;
//     int remainder  = h - (region * 43);   // range 0 - 42
//
//     int p, q, t;
//     p = v * (255 - s) / 255;
//     q = v * (255 - (s * remainder) / 43) / 255;
//     t = v * (255 - (s * (43 - remainder)) / 43) / 255;
//
//     if (region == 0)
//         return makeARGB(alpha, v, t, p);
//     else if (region == 1)
//         return makeARGB(alpha, q, v, p);
//     else if (region == 2)
//         return makeARGB(alpha, p, v, t);
//     else if (region == 3)
//         return makeARGB(alpha, p, q, v);
//     else if (region == 4)
//         return makeARGB(alpha, t, p, v);
//     else
//         return makeARGB(alpha, v, p, q);
// }
//
float rotateX(float x, float y, float min, float max, int mode)
{
    if (orientation == 1) {
        x = map(y, min, max, mode ? min : max, mode ? max : min);
    } else if (orientation == 2) {
        x = map(x, min, max, max, min);
    } else if (orientation == 3) {
        x = map(y, min, max, mode ? max : min, mode ? min : max);
    }
    return x;
}

float rotateY(float x, float y, float min, float max, int mode)
{
    if (orientation == 1) {
        y = map(x, min, max, mode ? max : min, mode ? min : max);
    } else if (orientation == 2) {
        y = map(y, min, max, max, min);
    } else if (orientation == 3) {
        y = map(x, min, max, mode ? min : max, mode ? max : min);
    }
    return y;
}

int rotateRectX(int x, int y, int w, int h, int min, int max)
{
    if (orientation == 1) {
        x = (int(rotateX(float(x), float(y), float(min), float(max), 1)) - 0) - 0;
    } else if (orientation == 2) {
        x = (int(rotateX(float(x), float(y), float(min), float(max), 1)) - w) + 1;
    } else if (orientation == 3) {
        x = (int(rotateX(float(x), float(y), float(min), float(max), 1)) - h) + 1;
    }
    return x;
}

int rotateRectY(int x, int y, int w, int h, int min, int max)
{
    if (orientation == 1) {
        y = (int(rotateY(float(x), float(y), float(min), float(max), 1)) - w) + 1;
    } else if (orientation == 2) {
        y = (int(rotateY(float(x), float(y), float(min), float(max), 1)) - h) + 1;
    } else if (orientation == 3) {
        y = (int(rotateY(float(x), float(y), float(min), float(max), 1)) + 0) + 0;
    }
    return y;
}

int rotateRectW(int w, int h)
{
    return (orientation == 1 || orientation == 3) ? h : w;
}

int rotateRectH(int w, int h)
{
    return (orientation == 1 || orientation == 3) ? w : h;
}

int mapTouchToRange (float v, float inMin, float inMax, float outMax)
{
    float mapped = map (v, inMin / 100.0, inMax / 100.0, 0.0, outMax);
    return int (mapped < 0.0 ? 0.0 : (mapped > outMax ? outMax : mapped) );
}

void performCC (float v, int cc, float inMin, float inMax, bool invert, int axyz, bool output, int index)
{
    int value = (mapTouchToRange (v, inMin, inMax, 16383.0));

//     if (axyz == 0 && index==1) {
//         log ((value >> 7) & 0x7F);
//         log ((value >> 0) & 0x7F);
//         log(99999999);
//         output=true;
//     } else {
//         output=false;
//     }
//
//

    int valueMSB = (value >> 7) & 0x7F;
    if (invert) valueMSB = 127 - valueMSB;
    if (sampleIndex>=0) setHeapByte( heapOffset(sampleIndex+1, index, axyz, 0), valueMSB);
    int offsetMSB = heapOffset(0, index, axyz, 0); // (index * 3 * 2) + (axyz * 2) + 0;
    int oldMSB = getHeapByte(offsetMSB);
    if (oldMSB != valueMSB) {
        setHeapByte( offsetMSB, valueMSB);
        if (output) sendCC((channel - 1), cc, valueMSB);
    }

    int valueLSB = (value >> 0) & 0x7F;
    if (invert) valueLSB = 127 - valueLSB;
    if (sampleIndex>=0) setHeapByte( heapOffset(sampleIndex+1, index, axyz, 1), valueLSB);
    int offsetLSB = heapOffset(0, index, axyz, 1); // (index * 3 * 2) + (axyz * 2) + 1;
    int oldLSB = getHeapByte(offsetLSB);
    if (oldLSB != valueLSB) {
        setHeapByte( offsetLSB, valueLSB);
        if (output && highres && cc < 32) sendCC((channel - 1), cc + 32, valueLSB);
    }
    performStamp = repaintCounter;
}


void handleGem(int g, float x, float y, float z, float vz)
{
    if (g >= 0 && g < 5) {
        if (z > 0.0 && zscale != 0.0 && z > zthreshold) {
            if (( (1.0 - zthreshold) / (z - zthreshold) )  != 0.0 ) {
                float scale = 1.0 + (zscale * ( 1.0 / ( (1.0 - zthreshold) / (z - zthreshold) ) ) );

                x = min(max (((x - 1.0) * scale) + 1.0, 0.0), 2.0 - 0.07);
                y = min(max (((y - 1.0) * scale) + 1.0, 0.0), 2.0 - 0.07);
            }
        }

        performCC(x, getXCC(g), 0.0 + 7.0, 200.0 - 7.0, false, 0, true, g);
        performCC(y, getYCC(g), 0.0 + 7.0, 200.0 - 7.0, true, 1, true, g);
        performCC(z, getZCC(g), 0.0, 100.0, false, 2, true, g);
    }
}


void handleSetup(float x, float y)
{
    int px = int(map(x, 0.07, 1.93, 0.0, 14.0));
    int py = int(map(y, 0.07, 1.93, 0.0, 14.0));
    int pg = -1;

    if (px == 0) {
        if (py < 4) {
            beat = !beat;
            setup = false;
        } else if (py < 8) {
            resetToCenter();
            setup = false;
        } else if (py < 12) {
        }
    } else if (px == 14) {
        if (py < 4) {
            recorder = 0;
            recordCount = 0;
            sampleIndex = 0;
            playing = false;
            setup = false;
        } else if (py < 8) {
            recorder = 1;
            recordCount = 4;
            setup = false;
        } else if (py < 12) {
//             recorder = 2;
//             recordCount = 8;
//             setup = false;
        }
    } else {
        if (py < 6 ) {
            if ( px < 6) {
                send = 1;
            } else if (px < 10) {
                send = 2;
            } else if (px < 14) {
                send = 3;
            }
        } else if (py < 11) {
            if (px < 8) {
                pg = 1;

            } else {
                pg = 3;
            }
        } else {
            if (px < 5) {
                pg = 0;
            } else if (px < 10) {
                pg = 2;
            } else {
                pg = 4;
            }
        }
    }
    if (pg>=0 && isActive(pg+1)) {
        primary = pg + 1;
        /* only send the MSB values */
        if (send ==0 || send ==1) sendCC((channel - 1), getXCC(pg), 64);
        if (send ==0 || send ==2) sendCC((channel - 1), getYCC(pg), 64);
        if (send ==0 || send ==3) sendCC((channel - 1), getZCC(pg), 64);
    }
}

void resetToCenter()
{
    for (int gem = 1; gem <= maxGems; gem++) {
        if (isActive(gem)) handleGem(gem-1, 1.0, 1.0, 0.0, 0.0);
    }
    clearData();
}

void clearData()
{
    for (int s = 0; s <= maxSamples; s++) {
        for (int g = 0; g < maxGems; g++) {
            for (int a = 0; a < maxAxyz; a++) {
                for (int b = 0; b < maxSignif; b++) {
                    setHeapByte( heapOffset(s,g,a,b), 0xFF);
                }
            }
        }
    }
}

void handleTouch(int index, float x,  float y, float z, float vz)
{
    int gem = index2gem(index);
    if (gem) {
        handleGem(gem-1, x, y, z, vz);
        fadePressureMap();
    }
}

void touchStart (int index, float x, float y, float z, float vz)
{
    touching ++;
    if (index >= 1 && index <= 5 && index2gem(index)) {
        touchBits = touchBits | (1 << (index - 1));
//         log(touchBits);
        if (!setup) {
            handleTouch(index, rotateX(x, y, 0.0, 2.0, 0), rotateY(x, y, 0.0, 2.0, 0), z, vz);
        }
    }
}

void touchMove (int index, float x, float y, float z, float vz)
{
    if (index >= 1 && index <= 5 && index2gem(index)) {
        touchBits = touchBits | (1 << (index - 1));
//            log(touchBits);
        if (!setup) {
            handleTouch(index, rotateX(x, y, 0.0, 2.0, 0), rotateY(x, y, 0.0, 2.0, 0), z, vz);
        }
    }
}

void touchEnd(int index, float x, float y, float z, float vz)
{
    touching --;
    if (index >= 1 && index <= 5 && index2gem(index)) {
        touchBits = touchBits &  ~(1 << (index - 1));
//         log(touchBits);
        if (setup) {
            handleSetup(rotateX(x, y, 0.0, 2.0, 0), rotateY(x, y, 0.0, 2.00, 0));
        }
    } else {
        resetToCenter();
    }
}

void handleButtonDown(int index) {
    if (setup) {
        setup = false;
    } else {
        buttonStamp = repaintCounter;
    }
}

void ensurePrimariIsActive() {
    int count=0;
    while (!isActive(primary) && count < maxGems) {
        count++;
        primary++;
    }
}

void handleButtonUp(int index) {
    if ((repaintCounter - buttonStamp) <=12) {
        primary = primary >= 5 ? 1 : primary + 1;
        ensurePrimariIsActive();
    }
    buttonStamp = 0;
}


void drawDot(int c,int a,int x,int y)
{
     if (x < 0) x = 0;
     if (x > 14) x = 14;
     if (y < 0) y = 0;
     if (y > 14) y = 14;
     blendPixel(c | (a << 24), int(rotateX(float(x), float(y), 0.0, 14.0, 1)), int(rotateY(float(x), float(y), 0.0, 14.0, 1)));
}


int getColourVariation(int index)
{
    int c = getColour(index);
    int max = 0xFFFFFF;
    int rnd = getRnd(index);
    if (clockCounter>=0) {
        if (beat4) {
            rnd = getRandomInt(max);
            setRnd(index,rnd);
        }
    } else {
        if (!(repaintCounter % 25)) {
            rnd = getRandomInt(max);
            setRnd(index,rnd);
        }
    }
    int b0 = (c >> 24) & 0xFF;
    int b1 = (c >> 16) & 0xFF;
    int b2 = (c >> 8)  & 0xFF;
    int b3 = (c >> 0)  & 0xFF;


    int delta = 4;
    if ((rnd % 4) == 0) b0 = b0 + ((rnd % delta) - (delta / 2));
    if ((rnd % 4) == 1) b1 = b1 + ((rnd % delta) - (delta / 2));
    if ((rnd % 4) == 2) b2 = b2 + ((rnd % delta) - (delta / 2));
    if ((rnd % 4) == 3) b3 = b3 + ((rnd % delta) - (delta / 2));

    return c;
}

int getColour(int index)
{
    if (index == 0) return dot1;
    if (index == 1) return dot2;
    if (index == 2) return dot3;
    if (index == 3) return dot4;
    if (index == 4) return dot5;

    return 0xFFFFFF;
}

void drawSetup()
{
    int xo = 2;
    int yo = 1;
    //drawNumber (99, 0x7FFFFFFF, 0, 0);

    int c = 0xFFFFFF;
    int a;

    a = (send == 1) ? 0xFF : 0x7F;

    // X shape
    drawDot(c, a, xo + 0, yo + 0);
    drawDot(c, a, xo + 2, yo + 0);
    drawDot(c, a, xo + 0, yo + 1);
    drawDot(c, a, xo + 2, yo + 1);
    drawDot(c, a, xo + 1, yo + 2);
    drawDot(c, a, xo + 0, yo + 3);
    drawDot(c, a, xo + 2, yo + 3);
    drawDot(c, a, xo + 0, yo + 4);
    drawDot(c, a, xo + 2, yo + 4);


    xo += 4;
    a = (send == 2) ? 0xFF : 0x7F;

    // Y shape
    drawDot(c, a, xo + 0, yo + 0);
    drawDot(c, a, xo + 2, yo + 0);
    drawDot(c, a, xo + 0, yo + 1);
    drawDot(c, a, xo + 2, yo + 1);
    drawDot(c, a, xo + 1, yo + 2);
    drawDot(c, a, xo + 1, yo + 3);
    drawDot(c, a, xo + 1, yo + 4);

    xo += 4;
    a = (send == 3) ? 0xFF : 0x7F;

    // Y shape
    drawDot(c, a, xo + 0, yo + 0);
    drawDot(c, a, xo + 1, yo + 0);
    drawDot(c, a, xo + 2, yo + 0);
    drawDot(c, a, xo + 2, yo + 1);
    drawDot(c, a, xo + 1, yo + 2);
    drawDot(c, a, xo + 0, yo + 3);
    drawDot(c, a, xo + 0, yo + 4);
    drawDot(c, a, xo + 1, yo + 4);
    drawDot(c, a, xo + 2, yo + 4);

    drawDot(0x00FF7F00, 0x4F, 0, 1);
    drawDot(0x00FF7F00, 0x7F, 0, 2);
    drawDot(0x00FF7F00, 0x4F, 0, 3);

    drawDot(0x00FFFF00, 0x4F, 0, 5);
    drawDot(0x00FFFF00, 0x7F, 0, 6);
    drawDot(0x00FFFF00, 0x4F, 0, 7);

//     drawDot(0x0000FFFF, 0x4F, 0, 9);
//     drawDot(0x0000FFFF, 0x7F, 0, 10);
//     drawDot(0x0000FFFF, 0x4F, 0, 11);

    drawDot(0x000000FF, 0x4F, 14, 1);
    drawDot(0x000000FF, 0x7F, 14, 2);
    drawDot(0x000000FF, 0x4F, 14, 3);

    drawDot(0x0000FFFF, 0x4F, 14, 5);
    drawDot(0x0000FFFF, 0x7F, 14, 6);
    drawDot(0x0000FFFF, 0x4F, 14, 7);

//     drawDot(0x000000FF, 0x4F, 14, 9);
//     drawDot(0x000000FF, 0x7F, 14, 10);
//     drawDot(0x000000FF, 0x4F, 14, 11);

    drawPressureMap();
    for (int p = 0; p<5; p++) {
        float flame = getFlame(p);
        if (!(repaintCounter % 5)) {
            flame = getRandomFloat();
            setFlame(p,flame);
        }
        float xf = map(((2.0 / 5)*p)+0.1, 0.0, 2.0, 0.07, 1.93);
        float yf = (p % 2) ? 1.1 : 1.65;
        addPressurePoint(getColourVariation(p), rotateX(xf, yf, 0.07, 1.93, 1), rotateY(xf, yf, 0.07, 1.93, 1), (((4 ) * 5.0) + (flame * 5)) + (0.3 * 75.0) );
        if (p == (primary - 1)) {
            xf *= 7.5;
            yf *= 7.5;
            blendCircle(0xFFFFFFFF,rotateX(xf, yf, 0.0, 15.0, 1), rotateY(xf, yf, 0.0, 15.0, 1), 0.4, true);
        }

    }
    fadePressureMap();
}


void drawGems()
{
    if (primary == 2) {
        drawDot(getColour(primary-1), 0x4F, 0, 0);
    } else if (primary == 3) {
        drawDot(getColour(primary-1), 0x4F, 0, 14);
    } else if (primary == 4) {
        drawDot(getColour(primary-1), 0x4F, 14, 0);
    } else if (primary == 5) {
        drawDot(getColour(primary-1), 0x4F, 14, 14);
    }
    for (int o=4; o>=0; o--) {
        int p = ((primary - 1) + o) % 5;

        float flame = getFlame(p);
        if (clockCounter>=0) {
            if (!(clockCounter % 3)) {
                flame = getRandomFloat();
                setFlame(p,flame);
            }
        } else {
            if (!(repaintCounter % 3)) {
                flame = getRandomFloat();
                setFlame(p,flame);
            }
        }

        int x = getHeapByte( heapOffset(0, p, 0, 0) );
        int y = getHeapByte( heapOffset(0, p, 1, 0) );
        int z = getHeapByte( heapOffset(0, p, 2, 0) );

        if (x > 127) continue;
        if (y > 127) continue;
        if (z > 127) z = 0;

        float xf = map(float(x), 0.0, 127.0, 0.07, 1.93);
        float yf = map(float(y), 0.0, 127.0, 1.93, 0.07);
        float zf = map(float(z), 0.0, 127.0, 0.0, 1.0);

        float scale = (((4 - o) * 8.0) + (flame * 24)) + (zf * 75.0);
        if (beat4) {
            addPressurePoint (getColourVariation(p), rotateX(xf, yf, 0.07, 1.93, 1), rotateY(xf, yf, 0.07, 1.93, 1), (((5 - o) * 16.0) + (flame * 24)) + (zf * 75.0));
        } else {
            addPressurePoint (getColourVariation(p), rotateX(xf, yf, 0.07, 1.93, 1), rotateY(xf, yf, 0.07, 1.93, 1), scale );
       }
    }


    drawPressureMap();
    fadePressureMap();

    for (int o=4; o>=0; o--) {
        int p = ((primary - 1) + o) % 5;

        int x = getHeapByte( heapOffset(0, p, 0, 0) );
        int y = getHeapByte( heapOffset(0, p, 1, 0) );

        if (x > 127) continue;
        if (y > 127) continue;

        float xf = map(float(x), 0.0, 127.0, 0.0, 14.0);
        float yf = map(float(y), 0.0, 127.0, 14.0, 0.0);
        blendCircle(0xFFFFFF | (   ((225 - ((o+1)*31)) + (getRnd(p) % 16))  << 24), rotateX(xf, yf, 0.0, 14.0, 1), rotateY(xf, yf, 0.0, 14.0, 1), 0.4, true);
    }
}

void centerNumber(int value,int colour)
{
   drawNumber(value,colour,(value<100?3:0) + (value < 10 ? 3 : 0) + (value == 1 ? -1 : 0),4);
}


void repaint()
{
    int colour = getColour(primary-1);
    int r = ((colour & 0xFF0000) >> 16);
    int g = ((colour & 0x00FF00) >> 8);
    int b = ((colour & 0x0000FF) >> 0);
    float factor = 8;
    int background = ((int(r / factor) & 0xFF) << 16) | ((int(g / factor) & 0xFF) << 8) | ((int(b / factor) & 0xFF) << 0);
    fillRect((primary == 1) ? 0xFF000000 : background, 0, 0, 15, 15);

    if (buttonStamp && (repaintCounter - buttonStamp) > 12) {
        setup = !setup;
        buttonStamp = 0;
    }

    if (setup) {
        drawSetup();
    } else {
        drawGems();
    }

    if (!setup) {
        if (recordCount && sampleIndex>=0 && playing) {
            centerNumber(sampleIndex + 1,0x7FFFFFFF);
        }
        if (beat && beat4) {
           drawDot(0xFFFFFF, 0xFF, 7, 0);
        }
        if (playback) {
           drawDot(0x0000FF, 0xFF, 7, 14); // ?
        }
    }


    if (beat4) beat4 = false;
    if (beat8) beat8 = false;
    if (beat16) beat16 = false;

    repaintCounter++;
    breathCounter++;
}

int getValue(int s, int g, int a)
{
    int value = 0xFFFF;
    int valueMSB = getHeapByte(heapOffset(s + 1,g,a,0));
    if (valueMSB >=0 && valueMSB <= 127) {
        value = valueMSB << 7;
        int valueLSB = getHeapByte(heapOffset(s + 1,g,a,1));
        if (valueLSB >=0 && valueLSB <= 127) {
            value = value | valueLSB;
        }

    }
    return value;
}

void handleMIDI(int byte0, int byte1, int byte2)
{
    if ((byte0 & 240) == 176) { // MIDI Control Change
        if ((repaintCounter - performStamp) < 12) return; // prevent feedback
        int ch = byte0 & 15;
        if ( (channel - 1) == ch) {
            int cc = byte1;
            int value = byte2;
            int ofst=-1;
            int ofstA=-1;
            int xx;
            int yy;
            float x=-1;
            float y=-1;
            for (int p = 0; p < 5; p++) {
                if (isActive(p+1)) {
                    if (getXCC(p) == cc) {
                        ofst =heapOffset(0, p, 0, 0);
                        ofstA = heapOffset(0, p, 1, 0);
                        xx = value;
                        yy = getHeapByte(ofstA);
                        x = map(float(xx), 0.0, 127.0, 0.0, 2.0);
                        y = map(float(yy), 0.0, 127.0, 2.0, 0.0);
                        if (clearOnCenter && (xx == 63 || xx == 0xFF) && (yy == 63 || yy == 0xFF)) {
                            setHeapByte(ofstA, 0xFF);
                            value=0xFF;
                        }
                    } else if (getYCC(p) == cc) {
                        ofst = heapOffset(0, p, 1, 0);
                        ofstA = heapOffset(0, p, 0, 0);
                        xx = getHeapByte(ofstA);
                        yy = value;
                        x = map(float(xx), 0.0, 127.0, 0.0, 2.0);
                        y = map(float(yy), 0.0, 127.0, 2.0, 0.0);
                        if (clearOnCenter && (xx == 63 || xx == 0xFF) && (yy == 63 || yy == 0xFF)) {
                            setHeapByte(ofstA, 0xFF);
                            value=0xFF;
                        }
                    } else if (getZCC(p) == cc) {
                        ofst = heapOffset(0, p, 2, 0);
                    } else if (getXCC(p) == (cc + 32) ) {
                        ofst = heapOffset(0, p, 0, 1);
                    } else if (getYCC(p) == (cc + 32)) {
                        ofst = heapOffset(0, p, 1, 1);
                    } else if (getZCC(p) == (cc + 32)) {
                        ofst = heapOffset(0, p, 2, 1);
                    }
                }
           }
           if (ofst >= 0) {
               if (getHeapByte(ofst) != value) {
                   setHeapByte(ofst, value);
               }
            }
        }
    } else if (byte0 == 248) { // MIDI clock
        clockCounter++;
        clockStamp = repaintCounter;

        pulseCounter = (clockCounter % 24);

        if (!pulseCounter && playing) {
            beat4 = true;
            beatCounter = (clockCounter / 24);

            if (recordCount || playback) {
                sampleIndex = beatCounter % recordCount;
                int s = beatCounter % recordCount;
                for (int g=0; g < maxGems; g++) {
                    if ((touchBits & (1 << g))== 0) {
                        for (int a=0; a < maxAxyz; a++) {
                            for (int b=0; b < maxSignif; b++) {
                                int value = getHeapByte(heapOffset(s + 1,g,a,b));
                                if (value > 0 && value <= 127) {
                                    if (getHeapByte(heapOffset(0,g,a,b)) != value) {
                                        if (isActive(g+1)) {
                                            int cc = ((a == 0) ? getXCC(g) : ((a == 1) ? getYCC(g) : getZCC(g))) + (b * 32) ;
                                            if (!b || (highres && cc >= 32 && cc < 64 ) ) sendCC((channel - 1), cc, value);
                                        }
                                        setHeapByte(heapOffset(0,g,a,b),value);
                                    }
                                } else {
                                  setHeapByte(heapOffset(s + 1,g,a,b),getHeapByte(heapOffset(0,g,a,b)));
                                }
                            }
                        }
                    }
                }
            }
        }

        if (playing && recordCount && clockCounter >= 0) {
            int s = beatCounter % recordCount;
//            s = (s > 0) ? (s - 1) : (recordCount - 1);

            int n = s < (recordCount - 1) ? (s + 1) : 0;

            for (int g=0; g < maxGems; g++) {
                    //log((touchBits & (1 << g)));
                if ((touchBits & (1 << g)) == 0) {
                    for (int a=0; a < maxAxyz; a++) {
                        int thisBeatValue = getValue(s,g,a);
                        int nextBeatValue = getValue(n,g,a);

                        if (thisBeatValue <= 16383 && nextBeatValue <= 16383) {

                            int diff = (nextBeatValue - thisBeatValue);
                            float step = float(diff) / 24; // ppqn
                            int value = int(float(thisBeatValue) + (step * pulseCounter));

                            int valueMSB = (value >> 7) & 0x7F;

                            if (getHeapByte(heapOffset(0,g,a,0)) != valueMSB) {
                                int cc = ((a == 0) ? getXCC(g) : ((a == 1) ? getYCC(g) : getZCC(g)));
                                setHeapByte(heapOffset(0,g,a,0), valueMSB);
                                sendCC((channel - 1), cc, valueMSB);

                                int valueLSB = (value >> 0) & 0x7F;
                                if (getHeapByte(heapOffset(0,g,a,1)) != valueLSB) {
                                    setHeapByte(heapOffset(0,g,a,1), valueLSB);
                                    if (highres && cc < 32) sendCC((channel - 1), cc + 32, valueLSB);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!((clockCounter+12)%12)) beat8 = true;
        if (!((clockCounter+12)%6)) beat16 = true;
    } else if (byte0 == 242) { // MIDI Song Position
       clockCounter = byte1 | (byte2 << 7);
       beatCounter = (clockCounter / 24);
       sampleIndex = beatCounter % recordCount;
    } else if (byte0 == 250) { // MIDI start
        playing = true;
    } else if (byte0 == 251) { // MIDI continue
        playing = true;
    } else if (byte0 == 252) { // MIDI stop
        playing = false;

    }
}


/*
<display backgroundColour="0xFF000000" textColour ="0xFFBBBBBB">
    <pixels>
        <pixel index="0" colour="0xFF000000" />
        <pixel index="1" colour="0xFF000000" />
        <pixel index="2" colour="0xFF000000" />
        <pixel index="3" colour="0xFF000000" />
        <pixel index="4" colour="0xFF000000" />
        <pixel index="5" colour="0xFF000000" />
        <pixel index="6" colour="0xFF000000" />
        <pixel index="7" colour="0xFF000000" />
        <pixel index="8" colour="0xFF000000" />
        <pixel index="9" colour="0xFF000000" />
        <pixel index="10" colour="0xFF000000" />
        <pixel index="11" colour="0xFF000000" />
        <pixel index="12" colour="0xFF000000" />
        <pixel index="13" colour="0xFF000000" />
        <pixel index="14" colour="0xFF000000" />
        <pixel index="15" colour="0xFF000000" />
        <pixel index="16" colour="0xFF000000" />
        <pixel index="17" colour="0xFF005B00" />
        <pixel index="18" colour="0xFF01AD01" />
        <pixel index="19" colour="0xFF005B00" />
        <pixel index="20" colour="0xFF000000" />
        <pixel index="21" colour="0xFF000000" />
        <pixel index="22" colour="0xFF000000" />
        <pixel index="23" colour="0xFF000000" />
        <pixel index="24" colour="0xFF000000" />
        <pixel index="25" colour="0xFF00005B" />
        <pixel index="26" colour="0xFF0101AD" />
        <pixel index="27" colour="0xFF00005B" />
        <pixel index="28" colour="0xFF000000" />
        <pixel index="29" colour="0xFF000000" />
        <pixel index="30" colour="0xFF000000" />
        <pixel index="31" colour="0xFF005B00" />
        <pixel index="32" colour="0xFF00CF00" />
        <pixel index="33" colour="0xFF5BFF5B" />
        <pixel index="34" colour="0xFF00CF00" />
        <pixel index="35" colour="0xFF005B00" />
        <pixel index="36" colour="0xFF000000" />
        <pixel index="37" colour="0xFF000000" />
        <pixel index="38" colour="0xFF000000" />
        <pixel index="39" colour="0xFF00005B" />
        <pixel index="40" colour="0xFF0000FF" />
        <pixel index="41" colour="0xFF5B5BFF" />
        <pixel index="42" colour="0xFF0000FF" />
        <pixel index="43" colour="0xFF00005B" />
        <pixel index="44" colour="0xFF000000" />
        <pixel index="45" colour="0xFF000000" />
        <pixel index="46" colour="0xFF01AD01" />
        <pixel index="47" colour="0xFF5BFF5B" />
        <pixel index="48" colour="0xFFB3FFB3" />
        <pixel index="49" colour="0xFF5BFF5B" />
        <pixel index="50" colour="0xFF01AD01" />
        <pixel index="51" colour="0xFF000000" />
        <pixel index="52" colour="0xFF000000" />
        <pixel index="53" colour="0xFF000000" />
        <pixel index="54" colour="0xFF0101AD" />
        <pixel index="55" colour="0xFF5B5BFF" />
        <pixel index="56" colour="0xFFB2B3FF" />
        <pixel index="57" colour="0xFF5B5BFF" />
        <pixel index="58" colour="0xFF0101AD" />
        <pixel index="59" colour="0xFF000000" />
        <pixel index="60" colour="0xFF000000" />
        <pixel index="61" colour="0xFF005B00" />
        <pixel index="62" colour="0xFF00CF00" />
        <pixel index="63" colour="0xFF5BFF5B" />
        <pixel index="64" colour="0xFF00CF00" />
        <pixel index="65" colour="0xFF005B00" />
        <pixel index="66" colour="0xFF000000" />
        <pixel index="67" colour="0xFF000000" />
        <pixel index="68" colour="0xFF000000" />
        <pixel index="69" colour="0xFF00005B" />
        <pixel index="70" colour="0xFF0000FF" />
        <pixel index="71" colour="0xFF5B5BFF" />
        <pixel index="72" colour="0xFF0000FF" />
        <pixel index="73" colour="0xFF00005B" />
        <pixel index="74" colour="0xFF000000" />
        <pixel index="75" colour="0xFF000000" />
        <pixel index="76" colour="0xFF000000" />
        <pixel index="77" colour="0xFF005B00" />
        <pixel index="78" colour="0xFF01AD01" />
        <pixel index="79" colour="0xFF005B00" />
        <pixel index="80" colour="0xFF000000" />
        <pixel index="81" colour="0xFF5B0000" />
        <pixel index="82" colour="0xFFAD0101" />
        <pixel index="83" colour="0xFF5B0000" />
        <pixel index="84" colour="0xFF000000" />
        <pixel index="85" colour="0xFF00005B" />
        <pixel index="86" colour="0xFF0101AD" />
        <pixel index="87" colour="0xFF00005B" />
        <pixel index="88" colour="0xFF000000" />
        <pixel index="89" colour="0xFF000000" />
        <pixel index="90" colour="0xFF000000" />
        <pixel index="91" colour="0xFF000000" />
        <pixel index="92" colour="0xFF000000" />
        <pixel index="93" colour="0xFF000000" />
        <pixel index="94" colour="0xFF000000" />
        <pixel index="95" colour="0xFF5B0000" />
        <pixel index="96" colour="0xFFFF0000" />
        <pixel index="97" colour="0xFFFD5B5B" />
        <pixel index="98" colour="0xFFFF0000" />
        <pixel index="99" colour="0xFF5B0000" />
        <pixel index="100" colour="0xFF000000" />
        <pixel index="101" colour="0xFF000000" />
        <pixel index="102" colour="0xFF000000" />
        <pixel index="103" colour="0xFF000000" />
        <pixel index="104" colour="0xFF000000" />
        <pixel index="105" colour="0xFF000000" />
        <pixel index="106" colour="0xFF000000" />
        <pixel index="107" colour="0xFF000000" />
        <pixel index="108" colour="0xFF000000" />
        <pixel index="109" colour="0xFF000000" />
        <pixel index="110" colour="0xFFAD0101" />
        <pixel index="111" colour="0xFFFD5B5B" />
        <pixel index="112" colour="0xFFFFB3B3" />
        <pixel index="113" colour="0xFFFD5B5B" />
        <pixel index="114" colour="0xFFAD0101" />
        <pixel index="115" colour="0xFF000000" />
        <pixel index="116" colour="0xFF000000" />
        <pixel index="117" colour="0xFF000000" />
        <pixel index="118" colour="0xFF000000" />
        <pixel index="119" colour="0xFF000000" />
        <pixel index="120" colour="0xFF000000" />
        <pixel index="121" colour="0xFF000000" />
        <pixel index="122" colour="0xFF000000" />
        <pixel index="123" colour="0xFF000000" />
        <pixel index="124" colour="0xFF000000" />
        <pixel index="125" colour="0xFF5B0000" />
        <pixel index="126" colour="0xFFFF0000" />
        <pixel index="127" colour="0xFFFD5B5B" />
        <pixel index="128" colour="0xFFFF0000" />
        <pixel index="129" colour="0xFF5B0000" />
        <pixel index="130" colour="0xFF000000" />
        <pixel index="131" colour="0xFF000000" />
        <pixel index="132" colour="0xFF000000" />
        <pixel index="133" colour="0xFF000000" />
        <pixel index="134" colour="0xFF000000" />
        <pixel index="135" colour="0xFF000000" />
        <pixel index="136" colour="0xFF000000" />
        <pixel index="137" colour="0xFF7F7F7F" />
        <pixel index="138" colour="0xFF000000" />
        <pixel index="139" colour="0xFF7F7F7F" />
        <pixel index="140" colour="0xFF000000" />
        <pixel index="141" colour="0xFF5B0000" />
        <pixel index="142" colour="0xFFAD0101" />
        <pixel index="143" colour="0xFF5B0000" />
        <pixel index="144" colour="0xFF000000" />
        <pixel index="145" colour="0xFF7F7F7F" />
        <pixel index="146" colour="0xFF7F7F7F" />
        <pixel index="147" colour="0xFF7F7F7F" />
        <pixel index="148" colour="0xFF000000" />
        <pixel index="149" colour="0xFF000000" />
        <pixel index="150" colour="0xFF000000" />
        <pixel index="151" colour="0xFF000000" />
        <pixel index="152" colour="0xFF7F7F7F" />
        <pixel index="153" colour="0xFF000000" />
        <pixel index="154" colour="0xFF7F7F7F" />
        <pixel index="155" colour="0xFF000000" />
        <pixel index="156" colour="0xFF000000" />
        <pixel index="157" colour="0xFF7F7F7F" />
        <pixel index="158" colour="0xFF000000" />
        <pixel index="159" colour="0xFF000000" />
        <pixel index="160" colour="0xFF7F7F7F" />
        <pixel index="161" colour="0xFF000000" />
        <pixel index="162" colour="0xFF000000" />
        <pixel index="163" colour="0xFF000000" />
        <pixel index="164" colour="0xFF000000" />
        <pixel index="165" colour="0xFF000000" />
        <pixel index="166" colour="0xFF000000" />
        <pixel index="167" colour="0xFF000000" />
        <pixel index="168" colour="0xFF7F7F7F" />
        <pixel index="169" colour="0xFF000000" />
        <pixel index="170" colour="0xFF000000" />
        <pixel index="171" colour="0xFF000000" />
        <pixel index="172" colour="0xFF7F7F7F" />
        <pixel index="173" colour="0xFF000000" />
        <pixel index="174" colour="0xFF000000" />
        <pixel index="175" colour="0xFF000000" />
        <pixel index="176" colour="0xFF7F7F7F" />
        <pixel index="177" colour="0xFF000000" />
        <pixel index="178" colour="0xFF000000" />
        <pixel index="179" colour="0xFF000000" />
        <pixel index="180" colour="0xFF000000" />
        <pixel index="181" colour="0xFF000000" />
        <pixel index="182" colour="0xFF7F7F7F" />
        <pixel index="183" colour="0xFF000000" />
        <pixel index="184" colour="0xFF7F7F7F" />
        <pixel index="185" colour="0xFF000000" />
        <pixel index="186" colour="0xFF7F7F7F" />
        <pixel index="187" colour="0xFF000000" />
        <pixel index="188" colour="0xFF7F7F7F" />
        <pixel index="189" colour="0xFF000000" />
        <pixel index="190" colour="0xFF000000" />
        <pixel index="191" colour="0xFF000000" />
        <pixel index="192" colour="0xFF7F7F7F" />
        <pixel index="193" colour="0xFF000000" />
        <pixel index="194" colour="0xFF000000" />
        <pixel index="195" colour="0xFF000000" />
        <pixel index="196" colour="0xFF000000" />
        <pixel index="197" colour="0xFF7F7F7F" />
        <pixel index="198" colour="0xFF000000" />
        <pixel index="199" colour="0xFF7F7F7F" />
        <pixel index="200" colour="0xFF000000" />
        <pixel index="201" colour="0xFF7F7F7F" />
        <pixel index="202" colour="0xFF000000" />
        <pixel index="203" colour="0xFF7F7F7F" />
        <pixel index="204" colour="0xFF000000" />
        <pixel index="205" colour="0xFF7F7F7F" />
        <pixel index="206" colour="0xFF7F7F7F" />
        <pixel index="207" colour="0xFF7F7F7F" />
        <pixel index="208" colour="0xFF000000" />
        <pixel index="209" colour="0xFF000000" />
        <pixel index="210" colour="0xFF000000" />
        <pixel index="211" colour="0xFF000000" />
        <pixel index="212" colour="0xFF000000" />
        <pixel index="213" colour="0xFF000000" />
        <pixel index="214" colour="0xFF000000" />
        <pixel index="215" colour="0xFF000000" />
        <pixel index="216" colour="0xFF000000" />
        <pixel index="217" colour="0xFF000000" />
        <pixel index="218" colour="0xFF000000" />
        <pixel index="219" colour="0xFF000000" />
        <pixel index="220" colour="0xFF000000" />
        <pixel index="221" colour="0xFF000000" />
        <pixel index="222" colour="0xFF000000" />
        <pixel index="223" colour="0xFF000000" />
        <pixel index="224" colour="0xFF000000" />
    </pixels>
</display>
*/

